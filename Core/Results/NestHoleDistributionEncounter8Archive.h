// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NESTHOLEDISTRIBUTIONENCOUNTER8ARCHIVE_STRUCTURE_H_
#define FLATBUFFERS_GENERATED_NESTHOLEDISTRIBUTIONENCOUNTER8ARCHIVE_STRUCTURE_H_

#include "flatbuffers/flatbuffers.h"

namespace structure {

struct NestHoleDistributionEncounter8Archive;
struct NestHoleDistributionEncounter8ArchiveBuilder;
struct NestHoleDistributionEncounter8ArchiveT;

struct NestHoleDistributionEncounter8Table;
struct NestHoleDistributionEncounter8TableBuilder;
struct NestHoleDistributionEncounter8TableT;

struct NestHoleDistributionEncounter8;
struct NestHoleDistributionEncounter8Builder;
struct NestHoleDistributionEncounter8T;

struct NestHoleDistributionEncounter8ArchiveT : public flatbuffers::NativeTable {
  typedef NestHoleDistributionEncounter8Archive TableType;
  std::vector<std::unique_ptr<structure::NestHoleDistributionEncounter8TableT>> Tables;
  NestHoleDistributionEncounter8ArchiveT() {
  }
};

struct NestHoleDistributionEncounter8Archive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NestHoleDistributionEncounter8ArchiveT NativeTableType;
  typedef NestHoleDistributionEncounter8ArchiveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>> *Tables() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>> *>(VT_TABLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLES) &&
           verifier.VerifyVector(Tables()) &&
           verifier.VerifyVectorOfTables(Tables()) &&
           verifier.EndTable();
  }
  NestHoleDistributionEncounter8ArchiveT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NestHoleDistributionEncounter8ArchiveT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NestHoleDistributionEncounter8Archive> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8ArchiveT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NestHoleDistributionEncounter8ArchiveBuilder {
  typedef NestHoleDistributionEncounter8Archive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Tables(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>>> Tables) {
    fbb_.AddOffset(NestHoleDistributionEncounter8Archive::VT_TABLES, Tables);
  }
  explicit NestHoleDistributionEncounter8ArchiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NestHoleDistributionEncounter8ArchiveBuilder &operator=(const NestHoleDistributionEncounter8ArchiveBuilder &);
  flatbuffers::Offset<NestHoleDistributionEncounter8Archive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NestHoleDistributionEncounter8Archive>(end);
    return o;
  }
};

inline flatbuffers::Offset<NestHoleDistributionEncounter8Archive> CreateNestHoleDistributionEncounter8Archive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>>> Tables = 0) {
  NestHoleDistributionEncounter8ArchiveBuilder builder_(_fbb);
  builder_.add_Tables(Tables);
  return builder_.Finish();
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8Archive> CreateNestHoleDistributionEncounter8ArchiveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>> *Tables = nullptr) {
  auto Tables__ = Tables ? _fbb.CreateVector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>>(*Tables) : 0;
  return structure::CreateNestHoleDistributionEncounter8Archive(
      _fbb,
      Tables__);
}

flatbuffers::Offset<NestHoleDistributionEncounter8Archive> CreateNestHoleDistributionEncounter8Archive(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8ArchiveT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NestHoleDistributionEncounter8TableT : public flatbuffers::NativeTable {
  typedef NestHoleDistributionEncounter8Table TableType;
  uint64_t TableID;
  uint32_t GameVersion;
  int8_t Field_02;
  int8_t Field_03;
  std::vector<std::unique_ptr<structure::NestHoleDistributionEncounter8T>> Entries;
  NestHoleDistributionEncounter8TableT()
      : TableID(0),
        GameVersion(0),
        Field_02(0),
        Field_03(0) {
  }
};

struct NestHoleDistributionEncounter8Table FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NestHoleDistributionEncounter8TableT NativeTableType;
  typedef NestHoleDistributionEncounter8TableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLEID = 4,
    VT_GAMEVERSION = 6,
    VT_FIELD_02 = 8,
    VT_FIELD_03 = 10,
    VT_ENTRIES = 12
  };
  uint64_t TableID() const {
    return GetField<uint64_t>(VT_TABLEID, 0);
  }
  uint32_t GameVersion() const {
    return GetField<uint32_t>(VT_GAMEVERSION, 0);
  }
  int8_t Field_02() const {
    return GetField<int8_t>(VT_FIELD_02, 0);
  }
  int8_t Field_03() const {
    return GetField<int8_t>(VT_FIELD_03, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>> *Entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TABLEID) &&
           VerifyField<uint32_t>(verifier, VT_GAMEVERSION) &&
           VerifyField<int8_t>(verifier, VT_FIELD_02) &&
           VerifyField<int8_t>(verifier, VT_FIELD_03) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(Entries()) &&
           verifier.VerifyVectorOfTables(Entries()) &&
           verifier.EndTable();
  }
  NestHoleDistributionEncounter8TableT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NestHoleDistributionEncounter8TableT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NestHoleDistributionEncounter8Table> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8TableT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NestHoleDistributionEncounter8TableBuilder {
  typedef NestHoleDistributionEncounter8Table Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TableID(uint64_t TableID) {
    fbb_.AddElement<uint64_t>(NestHoleDistributionEncounter8Table::VT_TABLEID, TableID, 0);
  }
  void add_GameVersion(uint32_t GameVersion) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8Table::VT_GAMEVERSION, GameVersion, 0);
  }
  void add_Field_02(int8_t Field_02) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8Table::VT_FIELD_02, Field_02, 0);
  }
  void add_Field_03(int8_t Field_03) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8Table::VT_FIELD_03, Field_03, 0);
  }
  void add_Entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>>> Entries) {
    fbb_.AddOffset(NestHoleDistributionEncounter8Table::VT_ENTRIES, Entries);
  }
  explicit NestHoleDistributionEncounter8TableBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NestHoleDistributionEncounter8TableBuilder &operator=(const NestHoleDistributionEncounter8TableBuilder &);
  flatbuffers::Offset<NestHoleDistributionEncounter8Table> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NestHoleDistributionEncounter8Table>(end);
    return o;
  }
};

inline flatbuffers::Offset<NestHoleDistributionEncounter8Table> CreateNestHoleDistributionEncounter8Table(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t TableID = 0,
    uint32_t GameVersion = 0,
    int8_t Field_02 = 0,
    int8_t Field_03 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>>> Entries = 0) {
  NestHoleDistributionEncounter8TableBuilder builder_(_fbb);
  builder_.add_TableID(TableID);
  builder_.add_Entries(Entries);
  builder_.add_GameVersion(GameVersion);
  builder_.add_Field_03(Field_03);
  builder_.add_Field_02(Field_02);
  return builder_.Finish();
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8Table> CreateNestHoleDistributionEncounter8TableDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t TableID = 0,
    uint32_t GameVersion = 0,
    int8_t Field_02 = 0,
    int8_t Field_03 = 0,
    const std::vector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>> *Entries = nullptr) {
  auto Entries__ = Entries ? _fbb.CreateVector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>>(*Entries) : 0;
  return structure::CreateNestHoleDistributionEncounter8Table(
      _fbb,
      TableID,
      GameVersion,
      Field_02,
      Field_03,
      Entries__);
}

flatbuffers::Offset<NestHoleDistributionEncounter8Table> CreateNestHoleDistributionEncounter8Table(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8TableT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NestHoleDistributionEncounter8T : public flatbuffers::NativeTable {
  typedef NestHoleDistributionEncounter8 TableType;
  uint32_t EntryIndex;
  uint32_t Species;
  uint32_t AltForm;
  uint32_t Level;
  uint16_t DynamaxLevel;
  uint32_t Field_05;
  uint32_t Field_06;
  uint32_t Field_07;
  uint32_t Field_08;
  uint32_t Field_09;
  uint32_t Field_0A;
  int8_t Ability;
  bool IsGigantamax;
  uint64_t DropTableID;
  uint64_t BonusTableID;
  std::vector<uint32_t> Probabilities;
  int8_t Gender;
  int8_t FlawlessIVs;
  int8_t ShinyFlag;
  int8_t Field_13;
  int8_t Field_14;
  int8_t Nature;
  uint32_t Field_16;
  uint32_t Move0;
  uint32_t Move1;
  uint32_t Move2;
  uint32_t Move3;
  float DynamaxBoost;
  uint32_t Field_1C;
  uint32_t Field_1D;
  uint32_t Shield;
  uint32_t AdditionalMove1Rate;
  uint32_t AdditionalMove1;
  uint32_t AdditionalMove1PP;
  uint32_t AdditionalMove2Rate;
  uint32_t AdditionalMove2;
  uint32_t AdditionalMove2PP;
  NestHoleDistributionEncounter8T()
      : EntryIndex(0),
        Species(0),
        AltForm(0),
        Level(0),
        DynamaxLevel(0),
        Field_05(0),
        Field_06(0),
        Field_07(0),
        Field_08(0),
        Field_09(0),
        Field_0A(0),
        Ability(0),
        IsGigantamax(false),
        DropTableID(0),
        BonusTableID(0),
        Gender(0),
        FlawlessIVs(0),
        ShinyFlag(0),
        Field_13(0),
        Field_14(0),
        Nature(0),
        Field_16(0),
        Move0(0),
        Move1(0),
        Move2(0),
        Move3(0),
        DynamaxBoost(0.0f),
        Field_1C(0),
        Field_1D(0),
        Shield(0),
        AdditionalMove1Rate(0),
        AdditionalMove1(0),
        AdditionalMove1PP(0),
        AdditionalMove2Rate(0),
        AdditionalMove2(0),
        AdditionalMove2PP(0) {
  }
};

struct NestHoleDistributionEncounter8 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NestHoleDistributionEncounter8T NativeTableType;
  typedef NestHoleDistributionEncounter8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTRYINDEX = 4,
    VT_SPECIES = 6,
    VT_ALTFORM = 8,
    VT_LEVEL = 10,
    VT_DYNAMAXLEVEL = 12,
    VT_FIELD_05 = 14,
    VT_FIELD_06 = 16,
    VT_FIELD_07 = 18,
    VT_FIELD_08 = 20,
    VT_FIELD_09 = 22,
    VT_FIELD_0A = 24,
    VT_ABILITY = 26,
    VT_ISGIGANTAMAX = 28,
    VT_DROPTABLEID = 30,
    VT_BONUSTABLEID = 32,
    VT_PROBABILITIES = 34,
    VT_GENDER = 36,
    VT_FLAWLESSIVS = 38,
    VT_SHINYFLAG = 40,
    VT_FIELD_13 = 42,
    VT_FIELD_14 = 44,
    VT_NATURE = 46,
    VT_FIELD_16 = 48,
    VT_MOVE0 = 50,
    VT_MOVE1 = 52,
    VT_MOVE2 = 54,
    VT_MOVE3 = 56,
    VT_DYNAMAXBOOST = 58,
    VT_FIELD_1C = 60,
    VT_FIELD_1D = 62,
    VT_SHIELD = 64,
    VT_ADDITIONALMOVE1RATE = 66,
    VT_ADDITIONALMOVE1 = 68,
    VT_ADDITIONALMOVE1PP = 70,
    VT_ADDITIONALMOVE2RATE = 72,
    VT_ADDITIONALMOVE2 = 74,
    VT_ADDITIONALMOVE2PP = 76
  };
  uint32_t EntryIndex() const {
    return GetField<uint32_t>(VT_ENTRYINDEX, 0);
  }
  uint32_t Species() const {
    return GetField<uint32_t>(VT_SPECIES, 0);
  }
  uint32_t AltForm() const {
    return GetField<uint32_t>(VT_ALTFORM, 0);
  }
  uint32_t Level() const {
    return GetField<uint32_t>(VT_LEVEL, 0);
  }
  uint16_t DynamaxLevel() const {
    return GetField<uint16_t>(VT_DYNAMAXLEVEL, 0);
  }
  uint32_t Field_05() const {
    return GetField<uint32_t>(VT_FIELD_05, 0);
  }
  uint32_t Field_06() const {
    return GetField<uint32_t>(VT_FIELD_06, 0);
  }
  uint32_t Field_07() const {
    return GetField<uint32_t>(VT_FIELD_07, 0);
  }
  uint32_t Field_08() const {
    return GetField<uint32_t>(VT_FIELD_08, 0);
  }
  uint32_t Field_09() const {
    return GetField<uint32_t>(VT_FIELD_09, 0);
  }
  uint32_t Field_0A() const {
    return GetField<uint32_t>(VT_FIELD_0A, 0);
  }
  int8_t Ability() const {
    return GetField<int8_t>(VT_ABILITY, 0);
  }
  bool IsGigantamax() const {
    return GetField<uint8_t>(VT_ISGIGANTAMAX, 0) != 0;
  }
  uint64_t DropTableID() const {
    return GetField<uint64_t>(VT_DROPTABLEID, 0);
  }
  uint64_t BonusTableID() const {
    return GetField<uint64_t>(VT_BONUSTABLEID, 0);
  }
  const flatbuffers::Vector<uint32_t> *Probabilities() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_PROBABILITIES);
  }
  int8_t Gender() const {
    return GetField<int8_t>(VT_GENDER, 0);
  }
  int8_t FlawlessIVs() const {
    return GetField<int8_t>(VT_FLAWLESSIVS, 0);
  }
  int8_t ShinyFlag() const {
    return GetField<int8_t>(VT_SHINYFLAG, 0);
  }
  int8_t Field_13() const {
    return GetField<int8_t>(VT_FIELD_13, 0);
  }
  int8_t Field_14() const {
    return GetField<int8_t>(VT_FIELD_14, 0);
  }
  int8_t Nature() const {
    return GetField<int8_t>(VT_NATURE, 0);
  }
  uint32_t Field_16() const {
    return GetField<uint32_t>(VT_FIELD_16, 0);
  }
  uint32_t Move0() const {
    return GetField<uint32_t>(VT_MOVE0, 0);
  }
  uint32_t Move1() const {
    return GetField<uint32_t>(VT_MOVE1, 0);
  }
  uint32_t Move2() const {
    return GetField<uint32_t>(VT_MOVE2, 0);
  }
  uint32_t Move3() const {
    return GetField<uint32_t>(VT_MOVE3, 0);
  }
  float DynamaxBoost() const {
    return GetField<float>(VT_DYNAMAXBOOST, 0.0f);
  }
  uint32_t Field_1C() const {
    return GetField<uint32_t>(VT_FIELD_1C, 0);
  }
  uint32_t Field_1D() const {
    return GetField<uint32_t>(VT_FIELD_1D, 0);
  }
  uint32_t Shield() const {
    return GetField<uint32_t>(VT_SHIELD, 0);
  }
  uint32_t AdditionalMove1Rate() const {
    return GetField<uint32_t>(VT_ADDITIONALMOVE1RATE, 0);
  }
  uint32_t AdditionalMove1() const {
    return GetField<uint32_t>(VT_ADDITIONALMOVE1, 0);
  }
  uint32_t AdditionalMove1PP() const {
    return GetField<uint32_t>(VT_ADDITIONALMOVE1PP, 0);
  }
  uint32_t AdditionalMove2Rate() const {
    return GetField<uint32_t>(VT_ADDITIONALMOVE2RATE, 0);
  }
  uint32_t AdditionalMove2() const {
    return GetField<uint32_t>(VT_ADDITIONALMOVE2, 0);
  }
  uint32_t AdditionalMove2PP() const {
    return GetField<uint32_t>(VT_ADDITIONALMOVE2PP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ENTRYINDEX) &&
           VerifyField<uint32_t>(verifier, VT_SPECIES) &&
           VerifyField<uint32_t>(verifier, VT_ALTFORM) &&
           VerifyField<uint32_t>(verifier, VT_LEVEL) &&
           VerifyField<uint16_t>(verifier, VT_DYNAMAXLEVEL) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_05) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_06) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_07) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_08) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_09) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_0A) &&
           VerifyField<int8_t>(verifier, VT_ABILITY) &&
           VerifyField<uint8_t>(verifier, VT_ISGIGANTAMAX) &&
           VerifyField<uint64_t>(verifier, VT_DROPTABLEID) &&
           VerifyField<uint64_t>(verifier, VT_BONUSTABLEID) &&
           VerifyOffset(verifier, VT_PROBABILITIES) &&
           verifier.VerifyVector(Probabilities()) &&
           VerifyField<int8_t>(verifier, VT_GENDER) &&
           VerifyField<int8_t>(verifier, VT_FLAWLESSIVS) &&
           VerifyField<int8_t>(verifier, VT_SHINYFLAG) &&
           VerifyField<int8_t>(verifier, VT_FIELD_13) &&
           VerifyField<int8_t>(verifier, VT_FIELD_14) &&
           VerifyField<int8_t>(verifier, VT_NATURE) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_16) &&
           VerifyField<uint32_t>(verifier, VT_MOVE0) &&
           VerifyField<uint32_t>(verifier, VT_MOVE1) &&
           VerifyField<uint32_t>(verifier, VT_MOVE2) &&
           VerifyField<uint32_t>(verifier, VT_MOVE3) &&
           VerifyField<float>(verifier, VT_DYNAMAXBOOST) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_1C) &&
           VerifyField<uint32_t>(verifier, VT_FIELD_1D) &&
           VerifyField<uint32_t>(verifier, VT_SHIELD) &&
           VerifyField<uint32_t>(verifier, VT_ADDITIONALMOVE1RATE) &&
           VerifyField<uint32_t>(verifier, VT_ADDITIONALMOVE1) &&
           VerifyField<uint32_t>(verifier, VT_ADDITIONALMOVE1PP) &&
           VerifyField<uint32_t>(verifier, VT_ADDITIONALMOVE2RATE) &&
           VerifyField<uint32_t>(verifier, VT_ADDITIONALMOVE2) &&
           VerifyField<uint32_t>(verifier, VT_ADDITIONALMOVE2PP) &&
           verifier.EndTable();
  }
  NestHoleDistributionEncounter8T *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NestHoleDistributionEncounter8T *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NestHoleDistributionEncounter8> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8T* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NestHoleDistributionEncounter8Builder {
  typedef NestHoleDistributionEncounter8 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_EntryIndex(uint32_t EntryIndex) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ENTRYINDEX, EntryIndex, 0);
  }
  void add_Species(uint32_t Species) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_SPECIES, Species, 0);
  }
  void add_AltForm(uint32_t AltForm) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ALTFORM, AltForm, 0);
  }
  void add_Level(uint32_t Level) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_LEVEL, Level, 0);
  }
  void add_DynamaxLevel(uint16_t DynamaxLevel) {
    fbb_.AddElement<uint16_t>(NestHoleDistributionEncounter8::VT_DYNAMAXLEVEL, DynamaxLevel, 0);
  }
  void add_Field_05(uint32_t Field_05) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_05, Field_05, 0);
  }
  void add_Field_06(uint32_t Field_06) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_06, Field_06, 0);
  }
  void add_Field_07(uint32_t Field_07) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_07, Field_07, 0);
  }
  void add_Field_08(uint32_t Field_08) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_08, Field_08, 0);
  }
  void add_Field_09(uint32_t Field_09) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_09, Field_09, 0);
  }
  void add_Field_0A(uint32_t Field_0A) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_0A, Field_0A, 0);
  }
  void add_Ability(int8_t Ability) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_ABILITY, Ability, 0);
  }
  void add_IsGigantamax(bool IsGigantamax) {
    fbb_.AddElement<uint8_t>(NestHoleDistributionEncounter8::VT_ISGIGANTAMAX, static_cast<uint8_t>(IsGigantamax), 0);
  }
  void add_DropTableID(uint64_t DropTableID) {
    fbb_.AddElement<uint64_t>(NestHoleDistributionEncounter8::VT_DROPTABLEID, DropTableID, 0);
  }
  void add_BonusTableID(uint64_t BonusTableID) {
    fbb_.AddElement<uint64_t>(NestHoleDistributionEncounter8::VT_BONUSTABLEID, BonusTableID, 0);
  }
  void add_Probabilities(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Probabilities) {
    fbb_.AddOffset(NestHoleDistributionEncounter8::VT_PROBABILITIES, Probabilities);
  }
  void add_Gender(int8_t Gender) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_GENDER, Gender, 0);
  }
  void add_FlawlessIVs(int8_t FlawlessIVs) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_FLAWLESSIVS, FlawlessIVs, 0);
  }
  void add_ShinyFlag(int8_t ShinyFlag) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_SHINYFLAG, ShinyFlag, 0);
  }
  void add_Field_13(int8_t Field_13) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_FIELD_13, Field_13, 0);
  }
  void add_Field_14(int8_t Field_14) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_FIELD_14, Field_14, 0);
  }
  void add_Nature(int8_t Nature) {
    fbb_.AddElement<int8_t>(NestHoleDistributionEncounter8::VT_NATURE, Nature, 0);
  }
  void add_Field_16(uint32_t Field_16) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_16, Field_16, 0);
  }
  void add_Move0(uint32_t Move0) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_MOVE0, Move0, 0);
  }
  void add_Move1(uint32_t Move1) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_MOVE1, Move1, 0);
  }
  void add_Move2(uint32_t Move2) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_MOVE2, Move2, 0);
  }
  void add_Move3(uint32_t Move3) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_MOVE3, Move3, 0);
  }
  void add_DynamaxBoost(float DynamaxBoost) {
    fbb_.AddElement<float>(NestHoleDistributionEncounter8::VT_DYNAMAXBOOST, DynamaxBoost, 0.0f);
  }
  void add_Field_1C(uint32_t Field_1C) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_1C, Field_1C, 0);
  }
  void add_Field_1D(uint32_t Field_1D) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_FIELD_1D, Field_1D, 0);
  }
  void add_Shield(uint32_t Shield) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_SHIELD, Shield, 0);
  }
  void add_AdditionalMove1Rate(uint32_t AdditionalMove1Rate) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1RATE, AdditionalMove1Rate, 0);
  }
  void add_AdditionalMove1(uint32_t AdditionalMove1) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1, AdditionalMove1, 0);
  }
  void add_AdditionalMove1PP(uint32_t AdditionalMove1PP) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE1PP, AdditionalMove1PP, 0);
  }
  void add_AdditionalMove2Rate(uint32_t AdditionalMove2Rate) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2RATE, AdditionalMove2Rate, 0);
  }
  void add_AdditionalMove2(uint32_t AdditionalMove2) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2, AdditionalMove2, 0);
  }
  void add_AdditionalMove2PP(uint32_t AdditionalMove2PP) {
    fbb_.AddElement<uint32_t>(NestHoleDistributionEncounter8::VT_ADDITIONALMOVE2PP, AdditionalMove2PP, 0);
  }
  explicit NestHoleDistributionEncounter8Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NestHoleDistributionEncounter8Builder &operator=(const NestHoleDistributionEncounter8Builder &);
  flatbuffers::Offset<NestHoleDistributionEncounter8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NestHoleDistributionEncounter8>(end);
    return o;
  }
};

inline flatbuffers::Offset<NestHoleDistributionEncounter8> CreateNestHoleDistributionEncounter8(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t EntryIndex = 0,
    uint32_t Species = 0,
    uint32_t AltForm = 0,
    uint32_t Level = 0,
    uint16_t DynamaxLevel = 0,
    uint32_t Field_05 = 0,
    uint32_t Field_06 = 0,
    uint32_t Field_07 = 0,
    uint32_t Field_08 = 0,
    uint32_t Field_09 = 0,
    uint32_t Field_0A = 0,
    int8_t Ability = 0,
    bool IsGigantamax = false,
    uint64_t DropTableID = 0,
    uint64_t BonusTableID = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> Probabilities = 0,
    int8_t Gender = 0,
    int8_t FlawlessIVs = 0,
    int8_t ShinyFlag = 0,
    int8_t Field_13 = 0,
    int8_t Field_14 = 0,
    int8_t Nature = 0,
    uint32_t Field_16 = 0,
    uint32_t Move0 = 0,
    uint32_t Move1 = 0,
    uint32_t Move2 = 0,
    uint32_t Move3 = 0,
    float DynamaxBoost = 0.0f,
    uint32_t Field_1C = 0,
    uint32_t Field_1D = 0,
    uint32_t Shield = 0,
    uint32_t AdditionalMove1Rate = 0,
    uint32_t AdditionalMove1 = 0,
    uint32_t AdditionalMove1PP = 0,
    uint32_t AdditionalMove2Rate = 0,
    uint32_t AdditionalMove2 = 0,
    uint32_t AdditionalMove2PP = 0) {
  NestHoleDistributionEncounter8Builder builder_(_fbb);
  builder_.add_BonusTableID(BonusTableID);
  builder_.add_DropTableID(DropTableID);
  builder_.add_AdditionalMove2PP(AdditionalMove2PP);
  builder_.add_AdditionalMove2(AdditionalMove2);
  builder_.add_AdditionalMove2Rate(AdditionalMove2Rate);
  builder_.add_AdditionalMove1PP(AdditionalMove1PP);
  builder_.add_AdditionalMove1(AdditionalMove1);
  builder_.add_AdditionalMove1Rate(AdditionalMove1Rate);
  builder_.add_Shield(Shield);
  builder_.add_Field_1D(Field_1D);
  builder_.add_Field_1C(Field_1C);
  builder_.add_DynamaxBoost(DynamaxBoost);
  builder_.add_Move3(Move3);
  builder_.add_Move2(Move2);
  builder_.add_Move1(Move1);
  builder_.add_Move0(Move0);
  builder_.add_Field_16(Field_16);
  builder_.add_Probabilities(Probabilities);
  builder_.add_Field_0A(Field_0A);
  builder_.add_Field_09(Field_09);
  builder_.add_Field_08(Field_08);
  builder_.add_Field_07(Field_07);
  builder_.add_Field_06(Field_06);
  builder_.add_Field_05(Field_05);
  builder_.add_Level(Level);
  builder_.add_AltForm(AltForm);
  builder_.add_Species(Species);
  builder_.add_EntryIndex(EntryIndex);
  builder_.add_DynamaxLevel(DynamaxLevel);
  builder_.add_Nature(Nature);
  builder_.add_Field_14(Field_14);
  builder_.add_Field_13(Field_13);
  builder_.add_ShinyFlag(ShinyFlag);
  builder_.add_FlawlessIVs(FlawlessIVs);
  builder_.add_Gender(Gender);
  builder_.add_IsGigantamax(IsGigantamax);
  builder_.add_Ability(Ability);
  return builder_.Finish();
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8> CreateNestHoleDistributionEncounter8Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t EntryIndex = 0,
    uint32_t Species = 0,
    uint32_t AltForm = 0,
    uint32_t Level = 0,
    uint16_t DynamaxLevel = 0,
    uint32_t Field_05 = 0,
    uint32_t Field_06 = 0,
    uint32_t Field_07 = 0,
    uint32_t Field_08 = 0,
    uint32_t Field_09 = 0,
    uint32_t Field_0A = 0,
    int8_t Ability = 0,
    bool IsGigantamax = false,
    uint64_t DropTableID = 0,
    uint64_t BonusTableID = 0,
    const std::vector<uint32_t> *Probabilities = nullptr,
    int8_t Gender = 0,
    int8_t FlawlessIVs = 0,
    int8_t ShinyFlag = 0,
    int8_t Field_13 = 0,
    int8_t Field_14 = 0,
    int8_t Nature = 0,
    uint32_t Field_16 = 0,
    uint32_t Move0 = 0,
    uint32_t Move1 = 0,
    uint32_t Move2 = 0,
    uint32_t Move3 = 0,
    float DynamaxBoost = 0.0f,
    uint32_t Field_1C = 0,
    uint32_t Field_1D = 0,
    uint32_t Shield = 0,
    uint32_t AdditionalMove1Rate = 0,
    uint32_t AdditionalMove1 = 0,
    uint32_t AdditionalMove1PP = 0,
    uint32_t AdditionalMove2Rate = 0,
    uint32_t AdditionalMove2 = 0,
    uint32_t AdditionalMove2PP = 0) {
  auto Probabilities__ = Probabilities ? _fbb.CreateVector<uint32_t>(*Probabilities) : 0;
  return structure::CreateNestHoleDistributionEncounter8(
      _fbb,
      EntryIndex,
      Species,
      AltForm,
      Level,
      DynamaxLevel,
      Field_05,
      Field_06,
      Field_07,
      Field_08,
      Field_09,
      Field_0A,
      Ability,
      IsGigantamax,
      DropTableID,
      BonusTableID,
      Probabilities__,
      Gender,
      FlawlessIVs,
      ShinyFlag,
      Field_13,
      Field_14,
      Nature,
      Field_16,
      Move0,
      Move1,
      Move2,
      Move3,
      DynamaxBoost,
      Field_1C,
      Field_1D,
      Shield,
      AdditionalMove1Rate,
      AdditionalMove1,
      AdditionalMove1PP,
      AdditionalMove2Rate,
      AdditionalMove2,
      AdditionalMove2PP);
}

flatbuffers::Offset<NestHoleDistributionEncounter8> CreateNestHoleDistributionEncounter8(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8T *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline NestHoleDistributionEncounter8ArchiveT *NestHoleDistributionEncounter8Archive::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<structure::NestHoleDistributionEncounter8ArchiveT> _o = std::unique_ptr<structure::NestHoleDistributionEncounter8ArchiveT>(new NestHoleDistributionEncounter8ArchiveT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NestHoleDistributionEncounter8Archive::UnPackTo(NestHoleDistributionEncounter8ArchiveT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = Tables(); if (_e) { _o->Tables.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Tables[_i] = std::unique_ptr<structure::NestHoleDistributionEncounter8TableT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8Archive> NestHoleDistributionEncounter8Archive::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8ArchiveT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNestHoleDistributionEncounter8Archive(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8Archive> CreateNestHoleDistributionEncounter8Archive(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8ArchiveT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NestHoleDistributionEncounter8ArchiveT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _Tables = _o->Tables.size() ? _fbb.CreateVector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8Table>> (_o->Tables.size(), [](size_t i, _VectorArgs *__va) { return CreateNestHoleDistributionEncounter8Table(*__va->__fbb, __va->__o->Tables[i].get(), __va->__rehasher); }, &_va ) : 0;
  return structure::CreateNestHoleDistributionEncounter8Archive(
      _fbb,
      _Tables);
}

inline NestHoleDistributionEncounter8TableT *NestHoleDistributionEncounter8Table::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<structure::NestHoleDistributionEncounter8TableT> _o = std::unique_ptr<structure::NestHoleDistributionEncounter8TableT>(new NestHoleDistributionEncounter8TableT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NestHoleDistributionEncounter8Table::UnPackTo(NestHoleDistributionEncounter8TableT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = TableID(); _o->TableID = _e; }
  { auto _e = GameVersion(); _o->GameVersion = _e; }
  { auto _e = Field_02(); _o->Field_02 = _e; }
  { auto _e = Field_03(); _o->Field_03 = _e; }
  { auto _e = Entries(); if (_e) { _o->Entries.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Entries[_i] = std::unique_ptr<structure::NestHoleDistributionEncounter8T>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8Table> NestHoleDistributionEncounter8Table::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8TableT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNestHoleDistributionEncounter8Table(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8Table> CreateNestHoleDistributionEncounter8Table(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8TableT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NestHoleDistributionEncounter8TableT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _TableID = _o->TableID;
  auto _GameVersion = _o->GameVersion;
  auto _Field_02 = _o->Field_02;
  auto _Field_03 = _o->Field_03;
  auto _Entries = _o->Entries.size() ? _fbb.CreateVector<flatbuffers::Offset<structure::NestHoleDistributionEncounter8>> (_o->Entries.size(), [](size_t i, _VectorArgs *__va) { return CreateNestHoleDistributionEncounter8(*__va->__fbb, __va->__o->Entries[i].get(), __va->__rehasher); }, &_va ) : 0;
  return structure::CreateNestHoleDistributionEncounter8Table(
      _fbb,
      _TableID,
      _GameVersion,
      _Field_02,
      _Field_03,
      _Entries);
}

inline NestHoleDistributionEncounter8T *NestHoleDistributionEncounter8::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<structure::NestHoleDistributionEncounter8T> _o = std::unique_ptr<structure::NestHoleDistributionEncounter8T>(new NestHoleDistributionEncounter8T());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void NestHoleDistributionEncounter8::UnPackTo(NestHoleDistributionEncounter8T *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = EntryIndex(); _o->EntryIndex = _e; }
  { auto _e = Species(); _o->Species = _e; }
  { auto _e = AltForm(); _o->AltForm = _e; }
  { auto _e = Level(); _o->Level = _e; }
  { auto _e = DynamaxLevel(); _o->DynamaxLevel = _e; }
  { auto _e = Field_05(); _o->Field_05 = _e; }
  { auto _e = Field_06(); _o->Field_06 = _e; }
  { auto _e = Field_07(); _o->Field_07 = _e; }
  { auto _e = Field_08(); _o->Field_08 = _e; }
  { auto _e = Field_09(); _o->Field_09 = _e; }
  { auto _e = Field_0A(); _o->Field_0A = _e; }
  { auto _e = Ability(); _o->Ability = _e; }
  { auto _e = IsGigantamax(); _o->IsGigantamax = _e; }
  { auto _e = DropTableID(); _o->DropTableID = _e; }
  { auto _e = BonusTableID(); _o->BonusTableID = _e; }
  { auto _e = Probabilities(); if (_e) { _o->Probabilities.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Probabilities[_i] = _e->Get(_i); } } }
  { auto _e = Gender(); _o->Gender = _e; }
  { auto _e = FlawlessIVs(); _o->FlawlessIVs = _e; }
  { auto _e = ShinyFlag(); _o->ShinyFlag = _e; }
  { auto _e = Field_13(); _o->Field_13 = _e; }
  { auto _e = Field_14(); _o->Field_14 = _e; }
  { auto _e = Nature(); _o->Nature = _e; }
  { auto _e = Field_16(); _o->Field_16 = _e; }
  { auto _e = Move0(); _o->Move0 = _e; }
  { auto _e = Move1(); _o->Move1 = _e; }
  { auto _e = Move2(); _o->Move2 = _e; }
  { auto _e = Move3(); _o->Move3 = _e; }
  { auto _e = DynamaxBoost(); _o->DynamaxBoost = _e; }
  { auto _e = Field_1C(); _o->Field_1C = _e; }
  { auto _e = Field_1D(); _o->Field_1D = _e; }
  { auto _e = Shield(); _o->Shield = _e; }
  { auto _e = AdditionalMove1Rate(); _o->AdditionalMove1Rate = _e; }
  { auto _e = AdditionalMove1(); _o->AdditionalMove1 = _e; }
  { auto _e = AdditionalMove1PP(); _o->AdditionalMove1PP = _e; }
  { auto _e = AdditionalMove2Rate(); _o->AdditionalMove2Rate = _e; }
  { auto _e = AdditionalMove2(); _o->AdditionalMove2 = _e; }
  { auto _e = AdditionalMove2PP(); _o->AdditionalMove2PP = _e; }
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8> NestHoleDistributionEncounter8::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8T* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNestHoleDistributionEncounter8(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NestHoleDistributionEncounter8> CreateNestHoleDistributionEncounter8(flatbuffers::FlatBufferBuilder &_fbb, const NestHoleDistributionEncounter8T *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NestHoleDistributionEncounter8T* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _EntryIndex = _o->EntryIndex;
  auto _Species = _o->Species;
  auto _AltForm = _o->AltForm;
  auto _Level = _o->Level;
  auto _DynamaxLevel = _o->DynamaxLevel;
  auto _Field_05 = _o->Field_05;
  auto _Field_06 = _o->Field_06;
  auto _Field_07 = _o->Field_07;
  auto _Field_08 = _o->Field_08;
  auto _Field_09 = _o->Field_09;
  auto _Field_0A = _o->Field_0A;
  auto _Ability = _o->Ability;
  auto _IsGigantamax = _o->IsGigantamax;
  auto _DropTableID = _o->DropTableID;
  auto _BonusTableID = _o->BonusTableID;
  auto _Probabilities = _o->Probabilities.size() ? _fbb.CreateVector(_o->Probabilities) : 0;
  auto _Gender = _o->Gender;
  auto _FlawlessIVs = _o->FlawlessIVs;
  auto _ShinyFlag = _o->ShinyFlag;
  auto _Field_13 = _o->Field_13;
  auto _Field_14 = _o->Field_14;
  auto _Nature = _o->Nature;
  auto _Field_16 = _o->Field_16;
  auto _Move0 = _o->Move0;
  auto _Move1 = _o->Move1;
  auto _Move2 = _o->Move2;
  auto _Move3 = _o->Move3;
  auto _DynamaxBoost = _o->DynamaxBoost;
  auto _Field_1C = _o->Field_1C;
  auto _Field_1D = _o->Field_1D;
  auto _Shield = _o->Shield;
  auto _AdditionalMove1Rate = _o->AdditionalMove1Rate;
  auto _AdditionalMove1 = _o->AdditionalMove1;
  auto _AdditionalMove1PP = _o->AdditionalMove1PP;
  auto _AdditionalMove2Rate = _o->AdditionalMove2Rate;
  auto _AdditionalMove2 = _o->AdditionalMove2;
  auto _AdditionalMove2PP = _o->AdditionalMove2PP;
  return structure::CreateNestHoleDistributionEncounter8(
      _fbb,
      _EntryIndex,
      _Species,
      _AltForm,
      _Level,
      _DynamaxLevel,
      _Field_05,
      _Field_06,
      _Field_07,
      _Field_08,
      _Field_09,
      _Field_0A,
      _Ability,
      _IsGigantamax,
      _DropTableID,
      _BonusTableID,
      _Probabilities,
      _Gender,
      _FlawlessIVs,
      _ShinyFlag,
      _Field_13,
      _Field_14,
      _Nature,
      _Field_16,
      _Move0,
      _Move1,
      _Move2,
      _Move3,
      _DynamaxBoost,
      _Field_1C,
      _Field_1D,
      _Shield,
      _AdditionalMove1Rate,
      _AdditionalMove1,
      _AdditionalMove1PP,
      _AdditionalMove2Rate,
      _AdditionalMove2,
      _AdditionalMove2PP);
}

inline const structure::NestHoleDistributionEncounter8Archive *GetNestHoleDistributionEncounter8Archive(const void *buf) {
  return flatbuffers::GetRoot<structure::NestHoleDistributionEncounter8Archive>(buf);
}

inline const structure::NestHoleDistributionEncounter8Archive *GetSizePrefixedNestHoleDistributionEncounter8Archive(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<structure::NestHoleDistributionEncounter8Archive>(buf);
}

inline bool VerifyNestHoleDistributionEncounter8ArchiveBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<structure::NestHoleDistributionEncounter8Archive>(nullptr);
}

inline bool VerifySizePrefixedNestHoleDistributionEncounter8ArchiveBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<structure::NestHoleDistributionEncounter8Archive>(nullptr);
}

inline void FinishNestHoleDistributionEncounter8ArchiveBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<structure::NestHoleDistributionEncounter8Archive> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNestHoleDistributionEncounter8ArchiveBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<structure::NestHoleDistributionEncounter8Archive> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<structure::NestHoleDistributionEncounter8ArchiveT> UnPackNestHoleDistributionEncounter8Archive(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<structure::NestHoleDistributionEncounter8ArchiveT>(GetNestHoleDistributionEncounter8Archive(buf)->UnPack(res));
}

inline std::unique_ptr<structure::NestHoleDistributionEncounter8ArchiveT> UnPackSizePrefixedNestHoleDistributionEncounter8Archive(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<structure::NestHoleDistributionEncounter8ArchiveT>(GetSizePrefixedNestHoleDistributionEncounter8Archive(buf)->UnPack(res));
}

}  // namespace structure

#endif  // FLATBUFFERS_GENERATED_NESTHOLEDISTRIBUTIONENCOUNTER8ARCHIVE_STRUCTURE_H_
